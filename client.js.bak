// Block class
class Block {
    constructor(index, timestamp, data, previousHash = "") {
        this.index = index;
        this.timestamp = timestamp;
        this.data = data;
        this.previousHash = previousHash;
        this.hash = this.calculateHash();
        this.nonce = 0; // Added nonce for proof of work
    }

    calculateHash() {
        return require("crypto")
            .createHash("sha256")
            .update(
                    this.index +
                    this.timestamp +
                    this.previousHash +
                    JSON.stringify(this.data) +
                    this.nonce
            )
            .digest("hex");
    }

    mineBlock(difficulty) {
        while (
            this.hash.substring(0, difficulty) !== Array(difficulty + 1).join("0")
        ) {
            this.nonce++;
            this.hash = this.calculateHash();
        }
    }
}

// Blockchain class
class Blockchain {
    constructor() {
        this.chain = [this.createGenesisBlock()];
        this.difficulty = 2; // Adjustable mining difficulty
    }

    createGenesisBlock() {
        return new Block(0, Date.now(), "Genesis Block", "0");
    }

    getLatestBlock() {
        return this.chain[this.chain.length - 1];
    }

    addBlock(newBlock) {
        newBlock.previousHash = this.getLatestBlock().hash;
        newBlock.mineBlock(this.difficulty);
        this.chain.push(newBlock);
    }

    isValidChain(chain) {
        for (let i = 1; i < chain.length; i++) {
            const currentBlock = chain[i];
            const previousBlock = chain[i - 1];

            if (currentBlock.previousHash !== previousBlock.hash) {
                return false;
            }

            if (currentBlock.hash !== currentBlock.calculateHash()) {
                return false;
            }
        }
        return true;
    }
}

const blockchain = new Blockchain(); // Create the blockchain
const express = require('express');
const app = express();

// Set up EJS as the template engine
app.set('view engine', 'ejs');

// Route to render the HTML page
app.get('/', (req, res) => {
    res.render('index', { port: port });
});


// Generate a random number between min (inclusive) and max (exclusive)
function getRandomInt(min, max) {
    return Math.floor(Math.random() * (max - min) + min);
}
  
let port = 0;

if (process.argv[2]) {
    port = Number(process.argv[2])
} else {
    port = getRandomInt(3001, 4000);
}
// Start the server on a given port
app.listen(port, () => {
    console.log(`Server running on port ${port}`);
});

const bodyParser = require("body-parser");
const axios = require("axios");

app.use(bodyParser.json());

let peers = []; // List of peer URLs

let updateTimestamp = 0;

app.get("/syncTimestamp", (req, res) => {
    res.send({ ts: updateTimestamp });
});

// Route to get the blockchain
app.get("/blockchain", (req, res) => {
    console.log('/blockchain called');
    
    res.send({ chain: blockchain.chain, difficulty: blockchain.difficulty });
    
    updateTimestamp = (new Date()).getTime();
});

// Route to mine a new block
app.post("/mineBlock", (req, res) => {
    const newBlockData = req.body.data;
    const newBlock = new Block(
        blockchain.chain.length,
        Date.now(),
        newBlockData
    );
    blockchain.addBlock(newBlock);

    // Broadcast the new block to peers
    broadcastNewBlock(newBlock);

    res.send({
        message: "Block mined and added to the chain.",
        block: newBlock,
    });
});

// Route to receive a new block from peers
app.post("/receiveNewBlock", (req, res) => {
    const newBlockData = req.body.newBlock;

    console.log("newBlock == "+JSON.stringify(newBlockData));

    // Reconstruct the block as an instance of Block
    const newBlock = new Block(
        newBlockData.index,
        newBlockData.timestamp,
        newBlockData.data,
        newBlockData.previousHash
    );
    newBlock.nonce = newBlockData.nonce;
    newBlock.hash = newBlockData.hash;

    // Validate the new block
    const latestBlock = blockchain.getLatestBlock();

    console.log("latestBlock == "+JSON.stringify(latestBlock))

    if (
        latestBlock.hash === newBlock.previousHash &&
        newBlock.hash === newBlock.calculateHash() &&
        newBlock.index === latestBlock.index + 1
    ) {
        blockchain.chain.push(newBlock);
        console.log("New block added to the chain from peer.");
        res.send({ message: "Block added successfully." });
    } else {
        console.log("Received invalid block from peer.");
        res.status(400).send({ message: "Invalid block received." });
    }
});

// Route to sync the blockchain with other peers
app.get("/sync", async (req, res) => {
    let peers = ['http://localhost:3000']
    
    for (const peer of peers) {
        try {
            const response = await axios.get(`${peer}/blockchain`);
            const peerChainData = response.data.chain;

            // Reconstruct the chain with Block instances
            const peerChain = peerChainData.map((blockData) => {
                const block = new Block(
                    blockData.index,
                    blockData.timestamp,
                    blockData.data,
                    blockData.previousHash
                );
                block.nonce = blockData.nonce;
                block.hash = blockData.hash;
                return block;
            });

            if (peerChain.length > blockchain.chain.length && blockchain.isValidChain(peerChain)) {
                blockchain.chain = peerChain;
                console.log(`Blockchain updated from peer: ${peer}`);
            }
        } catch (err) {
            console.error(`Failed to sync with peer: ${peer}`);
        }
    }
    res.send({ message: "Blockchain synced with peers." });
});

// Route to add a peer
app.post("/addPeer", (req, res) => {
    const peerUrl = req.body.peerUrl;
    if (!peers.includes(peerUrl)) {
        peers.push(peerUrl);
        console.log(`Peer added: ${peerUrl}`);
        res.send({ message: `Peer added: ${peerUrl}` });
    } else {
        res.status(400).send({ message: "Peer already exists." });
    }
});

function broadcastNewBlock(newBlock) {
    peers.forEach(async (peer) => {
        try {
            await axios.post(`${peer}/receiveNewBlock`, { newBlock });
        } catch (err) {
            console.error(`Failed to send new block to peer: ${peer} - Error: ${err.message}`);
        }
    });
}
